config wrm {
    label = "Warrior, Rogue & Mage"
    id = "wrm"
    description = "ISDL Build of Warrior, Rogue & Mage"
    author = "Roman Trevisanut"
}

actor Character {
    // ALTERNATE SHEET LAYOUT TEST
    // PAGE 1 - Play Area [DEFAULT]
    section Resources {
        // Calculate total health for the character.
        hidden number HealthMod
        hidden number HealthRegen
        health resource Health(max: {
            return self.Warrior + 6 + self.HealthMod
        })
        hidden number FateMod
        resource Fate(max: {
            if (self.Rogue == 0) {
                return 1 + self.FateMod
            }
            return self.Rogue + self.FateMod
        })
        string TestReadout(value: "Test")
        string ManaReadout(value: {
            return self.Mana + " Mana left"
        })
        hidden number ManaMult(min: 1, initial: 2)
        hidden number ManaMod
        resource Mana(max: {
            return (self.Mage * self.ManaMult + self.ManaMod)
        })
    }
    section Defenses {
        // Character Defense -- Using new formula where all ability scores contribute.
        hidden number DefenseBase(value:{return 4})
        hidden number DefenseAdjust(value: {return self.Warrior + self.Rogue + self.Mage})
        hidden number DefenseAdd(value: {return self.DefenseAdjust / 3})
        readonly number Defense(value: {return self.DefenseBase + self.DefenseAdd})
        readonly number ArmorAbsorb(value:{return self.ArmorRating})
    }
    section SkillRoll {
        string Ability(choices: ["Warrior","Rogue","Mage"])
        string Advantage(choices: ["None","Advantage","Disadvantage"])
        Skill Skill
        hidden number SkillBase(value:{
            if (self.Skill exists) {return self.Skill.system.skillbase}
            else {return 0}
        })
        number SkillBonus(value:{
            if (self.Skill exists) {return self.Skill.system.skilltotal}
            else {return 0}
        })
        number OtherModifier
        action Roll {
            fleeting Level = "None"
            if (self.Skill exists) {Level = self.Skill.system.skilllevel}
            fleeting Skill = "None"
            if (self.Skill exists) {Skill = self.Skill.name}
            fleeting Roll = roll(d6)
            if (self.Advantage == "None") {
                if (self.SkillBase > 0) {Roll = roll(1d6x + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(1d6 + self[self.Ability] + self.OtherModifier)}
            }
            if (self.Advantage == "Advantage") {
                if (self.Skill.system.Trained) {Roll = roll(2d6xkh + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(2d6kh + self[self.Ability] + self.OtherModifier)}
            }
            if (self.Advantage == "Disadvantage") {
                if (self.Skill.system.Trained) {Roll = roll(2d6xkl + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(2d6kl + self[self.Ability] + self.OtherModifier)}
            }
            chat RollOutcome {
                Roll
                tag self.Ability
                tag Skill
                tag Level
                tag self.Advantage
            }
        }
    }
    Skill[] Skills
    Language[] Languages
    // PAGE 2 -- MAGIC
    page Magic(icon: "fa-solid fa-sparkles", background: temple) {
        section Spellcasting {
            readonly number ManaCostPenalty(value: {return self.ArmorPenalty/2})
            readonly number SpellCastPenalty(value: {return self.ArmorPenalty/2})
            Spell Spell
            number Enhancements
            readonly number EnhancementCost(value: {
                if (self.Spell exists) {return self.Spell.system.mana / 2 * self.Enhancements}
                else {return 0}
            })
            number ManaCost(value: {
                if (self.Spell exists) {return self.Spell.system.mana + self.ManaCostPenalty + self.Enhancements}
                else {return 0}
            })
            number CastDL
        }
        section SpellRoller {
            // SPELL ROLLER HERE
        string CastingAbility(choices: ["Warrior","Rogue","Mage"])
        string CastAdvantage(choices: ["None","Advantage","Disadvantage"])
        Skill CastingSkill
        hidden number CastBase(value:{
            if (self.CastingSkill exists) {return self.Skill.system.skillbase}
            else {return 0}
        })
        number CastBonus(value:{
            if (self.CastingSkill exists) {return self.Skill.system.skilltotal}
            else {return 0}
        })
        number CastModifier
        action CastSpell {
            fleeting Level = "None"
            if (self.Skill exists) {Level = self.Skill.system.skilllevel}
            fleeting Skill = "None"
            if (self.Skill exists) {Skill = self.Skill.name}
            fleeting Roll = roll(d6)
            if (self.Advantage == "None") {
                if (self.SkillBase > 0) {Roll = roll(1d6x + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(1d6 + self[self.Ability] + self.OtherModifier)}
            }
            if (self.Advantage == "Advantage") {
                if (self.Skill.system.Trained) {Roll = roll(2d6xkh + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(2d6kh + self[self.Ability] + self.OtherModifier)}
            }
            if (self.Advantage == "Disadvantage") {
                if (self.Skill.system.Trained) {Roll = roll(2d6xkl + self[self.Ability] + self.SkillBonus + self.OtherModifier)}
                else {Roll = roll(2d6kl + self[self.Ability] + self.OtherModifier)}
            }
            chat RollOutcome {
                Roll
                tag self.Ability
                tag Skill
                tag Level
                tag self.Advantage
            }
        }
            string SpellsGo(choices: ["Brr","Zap","Woosh","WooWooooo"])
        }
        number SpellsKnown
        Spell[] Spells
        Talent[] Talents
    }
    // PAGE 3 -- Equipment
    page Belongings(icon: "fa-solid fa-backpack", background: diamonds) {
    section Armor {
        Armor WornArmor
        readonly number ArmorRating(value: {
            if (self.WornArmor exists) {
                return self.WornArmor.system.armorrating
                }
                return 0
                })
        readonly number ArmorPenalty(value: {
            if (self.ArmorRating < 1) {return 0}
            return self.ArmorRating - 1
        })
    }
        Weapon[] Weapons
        Armor[] Armors
        Consumable[] Consumables
        Item[] OtherItems
    }
    // PAGE 4 -- CONFIG/SETUP ITEMS
    page Config(icon: "fa-solid fa-cogs", background: circuitboard) {
        section Abilities {
            hidden number WarriorMax
            hidden number RogueMax
            hidden number MageMax
            number Warrior(min: 0, initial: 0, max: {return 6 + self.WarriorMax})
            number Rogue(min: 0, initial: 0, max: {return 6 + self.RogueMax})
            number Mage(min: 0, initial: 0, max: {return 6 + self.MageMax})
        }
        section Progression {
            number Advancements(min:0)
            readonly number MajorAdv(min: 0, value: {
                fleeting majAdv = Math.floor(self.Advancements / 4)
                fleeting randomBonus = Math.random()
                fleeting randomBonus2 = Math.random()
                fleeting smallerBonus = Math.min(randomBonus, randomBonus2)
                return majAdv + smallerBonus
            })
            number BonusAdv
        }
        Advancement[] Advancements
    }
}

//////// ITEMS BEGIN HERE
///////
/////
///
//

// LANGUAGE
item Language{
    string Type(choices: ["Common", "Uncommon", "Rare", "Dead", "Ancient"])
    string Fluency(choices: ["Native", "Conversant", "Fluent", "Broken", "Academic"])
}

// TALENT
item Talent {
    section Usage {
        string Trigger
        string Requirement
        string Activation(choices: ["Passive", "Action", "Reaction", "Special"])
        string UseLimit(choices: ["Passive","At-Will","Turn","Round","Battle","Day","Session"])
        number MaxUses
        pips UsesLeft(max: {return self.MaxUses})
    }
}

//SKILL
item Skill {
    string Ability(choices: [ "Warrior", "Rogue", "Mage" ])
    string SkillLevel(choices: [ "None","Trained","Expert","Master" ])
    number SkillMod
    hidden number SkillBase(value: {
        if (self.SkillLevel == "Master") {return 4}
        if (self.SkillLevel == "Expert") {return 3}
        if (self.SkillLevel == "Trained") {return 2}
        if (self.SkillLevel == "None") {return 0}
        return 0
    })
    readonly number SkillTotal(value: {return self.SkillBase + self.SkillMod})
}

// CONSUMABLE
item Consumable {
    string Type(choices:["Ammo","Elixir","Ration","Other"])
    string UseLimit(choices: ["N/A", "At-Will", "Turn", "Round", "Battle", "Day", "Session"])
    number MaxUses
    pips UsesLeft(max: {return self.MaxUses})
}

// WEAPON
item Weapon {
    section Use {
        string Ability(choices: [ "Warrior", "Rogue", "Mage" ])
        string Skill
    }
    section Qualities {
        number AttackMod
        number DamageMod
        number DiceCount
        string Limit(choices: [ "None","Max5","Max4","Max3"])
        string DamageType(choices: ["Cutting", "Piercing", "Bludgeoning", "Ballistic", "Explosive", "Magic", "Psychic", "Solar", "Fire", "Ice", "Corrosive", "Poison", "Spirit"])
    }
action Damage {
        fleeting damageRoll = roll((self.DiceCount)d6x + self.DamageMod)

        // Roll is #d6x [modified] + Damage Mod (6s explode)
        // Damage mods can be: Max5, Max4, Max3
        // Damage can have a type.
        if (self.Limit == "Max5") {
            damageRoll = roll((self.DiceCount)d6xmin1max5 + self.DamageMod)
        }
        else if (self.Limit == "Max4") {
            damageRoll = roll((self.DiceCount)d6xmin1max4 + self.DamageMod)
        }
        else if (self.Limit == "Max3") {
            damageRoll = roll((self.DiceCount)d6xmin1max3 + self.DamageMod)
        }

        chat AttackOutcome {
            damageRoll
            self.DamageType
        }
    }
}

// ITEM
item Item {
    section Flags{
        boolean AmmoItem
        boolean ConsumableItem
        boolean ClothingItem
        boolean ValuableItem
        boolean StoredItem
    }
    section Basic {
        number Count
        number Value
        readonly number TotalValue(value: {return self.Count * self.Value})
    }
    
    section ItemState {
        string Quality(choices: ["Poor", "Decent", "Fine", "Excellent", "Amazing"])
        string Structure(choices: ["New", "Decent", "Worn", "Damaged", "Ruined"])
        string Appearance(choices: ["Pristine", "Clean", "Stained", "Dirty", "Filthy"])
    }
    
    section Abilities{
        string RelevantAbility(choices: ["Warrior", "Rogue", "Mage"])
        string RelevantSkill
        number AccuracyMod
        number DamageMod
        number Dice
        number DiceMod
    }
    
    section Consumable{
        
    }
    section Weapon{
        boolean CanCut
        boolean CanPierce
        boolean CanBludgeon
        boolean MeleeWeapon
        boolean RangedWeapon
        boolean ThrowableWeapon
        number Range
    }
    section Clothing{
        string Descriptor(choices: ["Common","Rugged","Fine","Extravagant","Special"])
    }
    section Armor{
    }
    section Storage{
        string Location
    }
}

// SPELL
item Spell {
    section Basics {
        number Circle(initial: 1, max: 7)
        number Difficulty(value: {
            @js{let spellDLScale = [0, 5, 7, 9, 13, 19, 25, 31];}
            return @js{spellDLScale[system.circle]}
        })
        number Mana(value: {
            @js{let spellMPScale = [0, 1, 2, 4, 8, 16, 32, 64];}
            return @js{spellMPScale[system.circle]}
        })
        number Targets(value: {
            @js{let spellTargetScale = [0, 1, 2, 3, 5, 8, 13, 21];}
            return @js{spellTargetScale[system.circle]}
        })
        number DamageDice(value: {return self.Circle})
        number DamageMod(value: {return self.Circle})
        number FlatDamage(value: {return self.Circle})
    }
    section Effect{
        string DamageClass(choices: ["Physical","Magical"])
        string DamageType
        boolean Intangible
        string Range(choices: ["Touch", "Ranged", "Line of Sight"])
        number Yards
    }
    section Other {
        string Source(choices:["Innate","Channeled","Planar"])
        string Field(choices: ["Forming", "Shaping", "Twisting", "Unaligned"])
        string Practice
        string CastingAbility(choices: ["Warrior", "Rogue", "Mage"])
        string CastingSkill
        string Consumes(choices: ["Mana","Blood","Favor"])
    }
}

// ADVANCEMENT
item Advancement {
    string AdvancementType(choices: ["Standard","Major"])
    string AwardDate
    string IngameDate
}

// ARMOR
item Armor {
    number ArmorRating(max: {return 10})
    string ArmorState(choices:["Good","Worn","Battered","Damaged","Ruined"])
    hidden number ArmorReduction(value: {
        if (self.ArmorState == "Good") {return 0}
        if (self.ArmorState == "Worn") {return 0}
        if (self.ArmorState == "Battered") {return self.ArmorRating / 4}
        if (self.ArmorState == "Damaged") {return self.ArmorRating / 2}
        if (self.ArmorState == "Ruined") {return self.ArmorRating}
        return 0
    })
}

// EQUIPMENT [To be removed]
item Equipment {
    string Type(choices: ["Armor","Ring","Footwear","Gloves","Belt","Headwear","Cloak","Neckwear"])
    number Bonus
}
